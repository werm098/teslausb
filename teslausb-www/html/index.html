<!DOCTYPE html>
<html><head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="mobile-web-app-capable" content="yes">
<link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
<link rel="manifest" href="/icons/site.webmanifest">
<link rel="mask-icon" href="/icons/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="/icons/favicon.ico">
<link rel="stylesheet" href="filebrowser.css">
<link rel="stylesheet" href="contextmenu.css">
<script src="contextmenu.js"></script>
<script src="filebrowser.js"></script>
<meta name="msapplication-TileColor" content="#00aba9">
<meta name="msapplication-config" content="/icons/browserconfig.xml">
<meta name="theme-color" content="#ffffff">
<title>TeslaUSB</title>

<style>
html {
  height: 100%;
}

* {
  scroll-behavior: smooth;
}

html, body {
  font-family: Arial, sans-serif;
  height: 100vh;
  width: 100vw;
  margin: 0 0 0 0;
  overflow-x: hidden;
}

iframe {
  border: none;
}

.recordings {
  width:100%;
  height:100%;
}

.music {
  width:100%;
  height:100%;
}


/* The map doesn't resize properly in Firefox sometimes, ending up with scrollbars. Use Chrome instead. */
#sentrymap {
  width:100%;
  height:100%;
  border: 0;
}

.tabholder {
  position: relative;
  width:100%;
  height:100%;
  background: #fff;
}

.tabheaderholder {
  display: flex;
  flex-direction: row;
  position: fixed;
  top: 0;
  left: 0;
  height: 32px;
  width: 100%;
  align-items: baseline;
  padding-top: 3px;
  white-space: nowrap;
}

.hamburger {
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 36px;
  height: 32px;
  border: none;
  background: url(icons/hamburger.svg);
  z-index: 15;
}

.currenttabname {
  display: none;
  position: fixed;
  left: 0;
  right: 0;
  height: 32px;
  line-height: 32px;
  text-align: center;
  font-size: 22px;
}

.settingsbuttondiv {
  padding-left: 8px;
  flex: 0 0 22px;
  height: 22px;
  top: 6px;
  right: 2px;
  position: relative;
}

.tablabel {
  display: inline-block;
  margin: 0 2px 0 2px;
  padding: 3px 12px;
  position: relative;
  top: -3px;
  color: #444;
}

/* switch to dropdown tab navigation on narrow screens */
@media screen and (max-width: 824px) {
  .hamburger {
    display: block;
  }

  .tabheaderholder {
    // Changing the visibility to hide and show the menu in response
    // to a click appears to trigger a bug in Chrome that makes it
    // consume lots of CPU and makes some page interactions very
    // sluggish until the user performs another interaction like
    // toggling menu again with the hamburger button or clicking
    // on the filebrowser splitter.
    // Hiding and showing the menu by changing its position appears
    // to avoid the bug.
    //visibility: hidden;
    left: 100%;
    flex-direction: column;
    height: 100%;
    width: unset;
    top: 32px;
    background: #f8f8f8;
    z-index: 20;
    padding-right: 34px;
    border-right: 1000px solid rgba(0, 0, 0, 0.7);
    background-clip: padding-box;
  }

  .tablabel {
    font-size: 20px;
    padding: 10px 12px 10px 20px;
    width: 100%;
    z-index:10;
  }

  .tablabel:hover {
    background: #444;
    color: #fff;
  }

  .hamburger.brgropen ~ .tabheaderholder {
    //visibility: visible;
    left: 0;
  }
  .currenttabname {
    display: block;
  }

  .hamburger.brgropen ~ .tabheaderholder > .githublink {
    position: fixed;
    bottom: 14px;
    left: 16px;
  }

  .settingsbuttondiv {
    position: fixed;
    flex: unset;
    right: 2px;
    top: 6px;
    visibility: visible;
  }
}

.stretchable {
  display: inline-block;
  padding: 4px 12px;
  position: relative;
  top: 2px;
  flex-grow: 1;
  min-width: 2px;
}

.githublink {
  font-size: 70%;
}

.tab {
  position: fixed;
  top: 33px;
  bottom: 0;
  left: 0;
  visibility: hidden;
  width: 100%;
  background: #fff;
}

.tabradiobtn {
  display: none;
}

#tab1:checked ~ .tab.content1,
#tab2:checked ~ .tab.content2,
#tab3:checked ~ .tab.content3,
#tab4:checked ~ .tab.content4,
#tab5:checked ~ .tab.content5,
#tab6:checked ~ .tab.content6,
#tab7:checked ~ .tab.content7 {
  visibility: visible;
}

@media screen and (min-width: 825px) {
  .tablabel:hover {
    border-bottom: 3px solid #AAA;
    color: #000;
    z-index:10;
  }

  #tab1:checked ~ .tabheaderholder .tablabel1,
  #tab2:checked ~ .tabheaderholder .tablabel2,
  #tab3:checked ~ .tabheaderholder .tablabel3,
  #tab4:checked ~ .tabheaderholder .tablabel4,
  #tab5:checked ~ .tabheaderholder .tablabel5,
  #tab6:checked ~ .tabheaderholder .tablabel6,
  #tab7:checked ~ .tabheaderholder .tablabel7 {
    border-bottom: 3px solid red;
    color: #000;
    z-index:11;
  }
}

/*hide music tab by default */
.tablabel6 {
  display: none;
}

button {
  padding:6px;
}

.group2 {
  width: 200px;
}

.mypre {
  width:100%;
  height:calc(100% - 50px);
  padding-top: 0px;
  padding-bottom: 4px;
  padding-left: 4px;
  margin-top: 2px;
  margin-bottom: 4px;
  overflow:auto;
  border-top:1px solid black;
  border-bottom:1px solid black;
}

td {
  padding:0px;
}

video {
  padding:0px;
}

.flipped {
  -moz-transform: scale(-1, 1);
  -webkit-transform: scale(-1, 1); -o-transform: scale(-1, 1);
  transform: scale(-1, 1); filter: FlipH;
}

.videoholder {
  background-color: #333;
  width:100%;
  height: 100%;
  display: grid;
  grid-template-columns: 33% 34% 33%;
  grid-template-rows: auto;
}

.videoholder.layout1 {
  grid-template-areas:
    "leftview frontview rightview"
    "mapview backview infoview";
}

.videoholder.layout2 {
  grid-template-areas:
    "mapview frontview infoview"
    "leftview backview rightview";
}

.videoholder.layout3 {
  grid-template-areas:
    "mapview frontview infoview"
    "rightview backview leftview";
}

.videoholder.layout4 {
  grid-template-columns: 20% 30% 30% 20%;
  grid-template-areas:
    ". frontview frontview ."
    "leftview leftview rightview rightview"
    ". backview backview ."
    "mapview mapview infoview infoview";
}

.videoholder.layout5 {
  grid-template-columns: 20% 30% 30% 20%;
  grid-template-areas:
    ". frontview frontview ."
    "rightview rightview leftview leftview"
    ". backview backview ."
    "mapview mapview infoview infoview";
}

.videogriditem {
  min-width: 0;
  max-width: 100%;
  align-self: center;
}

.leftview {
  grid-area: leftview;
}

.frontview {
  grid-area: frontview;
}

.rightview {
  grid-area: rightview;
}

.mapview {
  grid-area: mapview;
  height: 100%;
}

.backview {
  grid-area: backview;
}

.infoview {
  grid-area: infoview;
  align-self: start;
}

.navbar {
  overflow: hidden;
  background-color: #333;
}

.navbar a {
  float: left;
  font-size: 16px;
  color: white;
  text-align: center;
  padding: 14px 16px;
  text-decoration: none;
}

.subnav,.noclips {
  float: left;
  overflow: hidden;
  font-size: 16px;
  border: none;
  outline: none;
  color: white;
  padding: 14px 12px;
  background-color: inherit;
  font-family: inherit;
  margin: 0;
}

.noclips {
  color: grey;
}

/*
 disable the loading/norecordings indicator on browsers that
 don't support the :has selector (firefox and older chrome)
*/
@supports not selector(:has(+ *)) {
  .noclips {
    display: none;
  }
}

/* highlight category that holds the currently selected clip */
.subnav:has( .selected) {
  text-decoration: underline 2px;
}

/* only show "No recordings" item when all categories are empty */
.navbar:has( .subnav-content:not(:empty):not(#layouts)) .noclips {
  display: none;
}

/* hide clips categories that are empty */
.subnav:has( .subnav-content:empty) {
  display: none;
}

.subnav.layoutbtn {
  float: right;
  padding: 6px;
}

#layouts.subnav-content {
  left: initial;
  right: 0;
  width: 180px;
}

#layouts.subnav-content .dropdownitem {
  width: 164px;
  height: 36px;
}

#layouts.subnav-content .dropdownitem.selected {
  text-decoration: underline 2px;
  font-weight: bold;
}

.navbar a:hover, .subnav:hover {
  background-color: rgb(100,100,100);
}

.navbar a:hover, .subnav:hover .layoutsvg {
  background-color: rgb(100,100,100);
  fill: white;
  stroke: white;
  stroke-width: 1px;
}

.layoutsvg {
  width: 100%;
  height: 100%;
  fill: #d0d0d0;
  stroke: #d0d0d0;
  stroke-width: 1px;
  opacity: 1;
  margin-top: 2px;
  margin-left: 1px;
}

.subnav-content {
  display: none;
  position: absolute;
  background-color: rgba(100,100,100,0.7);
  left: 2px;
  width: 70%;
  z-index: 12;
  margin-top: 13px;
  overflow-y: auto;
  max-height: calc(100% - 45px);
}

#layouts.subnav-content {
  margin-top: 6px;
}

.dropdownitem {
  float: left;
  color: white;
  text-align: left;
  text-decoration: none;
  width: 140px;
  min-height: 36px;
  padding: 10px 8px;
}

.dropdownitem.selected .dropdownitemmain {
  text-decoration: underline 2px;
  font-weight: bold;
}

.dropdownitemmain:has(~ .dropdownitemsub.selected) {
  text-decoration: underline 2px;
  font-weight: bold;
}

.dropdownitemdayname {
  color: #d0d0d0;
  font-size: smaller;
}

.dropdownitem:hover .dropdownitemdayname {
  color: #303030;
  font-size: smaller;
}

.dropdownitemsub {
  color: #d0d0d0;
  font-size: smaller;
  float: left;
}

.dropdownitemsub.selectable {
  padding-left: 6px;
  padding-right: 6px;
  padding-top: 2px;
  padding-bottom: 2px;
}

.dropdownitemsub.selectable.selected {
  text-decoration: underline 2px;
  font-weight: bold;
}

.dropdownitem:hover .dropdownitemsub.selectable:hover {
  color: white;
  background-color: #303030;
}

.dropdownitem:hover .dropdownitemsub {
  color: #303030;
  font-size: smaller;
}

.subnav-content .dropdownitem:hover {
  background-color: #eee;
  color: black;
}

.subnav:hover .subnav-content {
  display: block;
}

.slider {
    margin-left: .4rem;
    margin-right: .4rem;
    margin-top: 0;
    margin-bottom: 0;
}

.sliderpositionbubble {
  --position: 100px;
  position: absolute;
  left: var(--position);
  top: -20px;
  width: 60px;
  height: 25px;
  line-height: 25px;
  text-align: center;
  border-radius: 6px;
  color: white;
  background: white;
  color: black;
  opacity: 0;
  transition: opacity 1s;
  transition-delay: 0.5s;
}

@media(hover: hover) {
  .slider:hover ~ .sliderpositionbubble {
    opacity: 1;
    transition: opacity 0.5s;
    transition-delay: 0s;
  }
}

#videocontrols {
  opacity: 0.0;
  z-index: 2;
  margin: 0;
  position: fixed;
  top: calc(100% - 100px);
  width: 100%;
  height: 100px;
  background-color: #555;
  transition: opacity 0.5s;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

#videocontrols:hover {
  opacity: 0.7;
  transition: opacity 0.5s;
}

#videocontrols.shown {
  opacity: 0.7;
  transition: opacity 0.5s;
}

.settingsbutton {
  width: 22px;
  height: 100%;
  fill: grey;
  stroke: grey;
  stroke-width: 1px;
  opacity: 1;
}

.settingsbutton:hover {
  width: 22px;
  height: 100%;
  fill: black;
  stroke: black;
  stroke-width: 1px;
  opacity: 1;
}

.modaloverlay {
  display: none;
  position: fixed;
  z-index: 90;
  left: 0;
  top: 0;
  width: 100%;
  height: 100%;
  overflow: auto;
  background-color: rgb(0,0,0);
  background-color: rgba(0,0,0,0.4);
}

.modalcontent {
  background-color: white;
  margin: 15% auto;
  padding: 10px;
  border: 2px solid #888;
  width: 70%;
}
.closebutton {
  color: #aaa;
  float: right;
  font-size: 28px;
  font-weight: bold;
}

.closebutton:hover,.closebutton:focus {
  color: black;
  text-decoration: none;
  cursor: pointer;
}

.mediabutton {
  width: 100%;
  height: 100%;
  fill: #d0d0d0;
  stroke: #d0d0d0;
  stroke-width: 3px;
}

.mediabutton:hover {
  fill: white;
  stroke: white;
  width: 100%;
  height: 100%;
}

/* the play/pause button is done with CSS in Chrome, and html/javascript
   in Firefox, because Firefox doesn't support setting paths in css */
.play svg path {
  d: path('M 8,30 30,18 8,6 z') !important;
}

.pause svg path {
  d: path('M 8,30 14,30 14,6 8,6 z M 24,30 30,30 30,6 24,6 z') !important;
}

/* Firefox doesn't support setting svg paths in css, so these are set
   in the html instead. */
.skipback svg path {
  fill: none;
  /* d: path('M 19,28 A 10,10 0 1 0 9,18 M 8,18 10,18 9,20 z') !important; */
}

.skipforward svg path {
  fill: none;
  /* d: path('M 19,28 A 10,10 0 1 1 29,18 M 28,18 30,18 29,20 z') !important; */
}

.flatbutton {
  width: 50px;
  height: 50px;
  border: 0;
  background: none;
  box-shadow: none;
  border-radius: 0px;
  display: inline-block;
  margin: 0 auto;
}

.buttoncontainer {
  margin: 0 auto;
  display: inline-block;
}

.status_wifi {
  margin: auto;
  display: flex;
  flex-direction: row;
}

.wifi-icon[strength*="++++"] > .wifi-high {
  stroke: blue;
}

.wifi-icon[strength*="+++"] > .wifi-medium {
  stroke: blue;
}

.wifi-icon[strength*="++"] > .wifi-low {
  stroke: blue;
}

.wifi-icon[strength*="+"] > .wifi-none {
  stroke: blue;
}

.wifi-icon[strength="-"] > .wifi-none {
  stroke: lightgrey;
  fill: lightgrey;
}

/* put some horizontal spacing between the children of the wifi row */
.status_wifi > *:not(:last-child) {
  margin-right: 7px;
}

.flatbutton:hover {
  color: white;
}

.pistatus {
  position: relative;
  padding: 5px;
  margin-bottom: 10px;
  border: 1px solid lightgrey;
}

/* put some vertical spacing between the children of the status area */
.pistatus > *:not(:last-child) {
  margin-bottom: 3px;
}

</style>
</head>
<body>
<div class="tabholder">
  <div class="hamburger" onclick="toggleHamburgerMenu();"></div>
  <div class="currenttabname" onclick="toggleHamburgerMenu();"></div>
  <input class="tabradiobtn" type="radio" name="tabs" id="tab1">
  <input class="tabradiobtn" type="radio" name="tabs" id="tab2">
  <input class="tabradiobtn" type="radio" name="tabs" id="tab3">
  <input class="tabradiobtn" type="radio" name="tabs" id="tab4">
  <input class="tabradiobtn" type="radio" name="tabs" id="tab5">
  <input class="tabradiobtn" type="radio" name="tabs" id="tab6">
  <input class="tabradiobtn" type="radio" name="tabs" id="tab7" checked>
  <div class="tabheaderholder">
    <label for="tab1" class="tablabel tablabel1">Diagnostics</label>
    <label for="tab2" class="tablabel tablabel2">Archiveloop log</label>
    <label for="tab3" class="tablabel tablabel3">Setup log</label>
    <label for="tab4" class="tablabel tablabel4">Tools</label>
    <label for="tab5" class="tablabel tablabel5">Recordings</label>
    <label for="tab6" class="tablabel tablabel6">Files</label>
    <label for="tab7" class="tablabel tablabel7">Viewer</label>

    <div class="stretchable"></div>

    <a href="https://www.github.com/marcone/teslausb" target="_blank" class="githublink">TeslaUSB on GitHub</a>

    <div class="settingsbuttondiv" title="Settings">
      <svg class="settingsbutton" viewBox="0 0 38 38">
        <path d="M12 6l1-5c1-1 7-1 8 0l1 5a10 10 0 015 4l-16 6zM24.892 7.67l4.83-1.634c1.366.366 4.366 5.562 4 6.928l-3.83 3.366a10 10 0 01-.964 6.33L15.732 11.804zM29.892 19.67l3.83 3.366c.366 1.366-2.634 6.562-4 6.928l-4.83-1.634a10 10 0 01-5.964 2.33l2.804-16.856zM22 30l-1 5c-1 1-7 1-8 0l-1-5a10 10 0 01-5-4l16-6zM9.108 28.33l-4.83 1.634c-1.366-.366-4.366-5.562-4-6.928l3.83-3.366a10 10 0 01.964-6.33l13.196 10.856zM4.108 16.33l-3.83-3.366c-.366-1.366 2.634-6.562 4-6.928l4.83 1.634a10 10 0 015.964-2.33l-2.804 16.856z"/>
      </svg>
    </div>
  </div>

  <div class="tab content1">
    <div style="width:100%;height:calc(100% - 4px)">
      <pre class="mypre" id="diagnosticspre">...</pre>
      <div style="padding:4px;">
        <button class="group1" id="diagrefreshbtn" onclick="refreshdiagnostics();">Refresh diagnostics</button>
        <button class="group1" id="diagdwnbtn" onclick="download('diagnostics.txt', document.getElementById('diagnosticspre').textContent);">Download diagnostics</button>
      </div>
    </div>
  </div>

  <div class="tab content2">
    <div style="width:100%;height:calc(100% - 4px)">
      <pre class="mypre" id="archivelooppre">Loading...</pre>
      <div style="padding:4px;">
        <button class="group1" id="aldwnbtn" onclick="download('archiveloop.log', document.getElementById('archivelooppre').textContent);">Download archiveloop log</button>
      </div>
    </div>
  </div>

  <div class="tab content3">
    <div style="width:100%;height:calc(100% - 4px)">
      <pre class="mypre" id="setuplogpre">Loading...</pre>
      <div style="padding:4px;">
        <button class="group1" id="sudwnbtn" onclick="download('teslausb-headless-setup.log', document.getElementById('setuplogpre').textContent);">Download setup log</button>
      </div>
    </div>
  </div>

  <div class="tab content4">
    <div style="width:calc(100% - 4px);margin: 2px;">
      <div class="pistatus">
        <div class="status_uptime"></div>
        <div class="status_temp"></div>
        <div class="status_drives"></div>
        <div class="status_space"></div>
        <div class="status_snapshots"></div>
        <div class="status_ether">
          <span>Ethernet:
            <span class="status_ether_info">&ZeroWidthSpace;</span>
          </span>
        </div>
        <div class="status_wifi">
          <span>Wifi:
            <span class="status_wifi_info">&ZeroWidthSpace;</span>
          </span>
          <span class="wifi-icon-span" title="">
            <svg width="20" height="18" viewBox="0 5 110 95">
              <g class="wifi-icon" strength="a">
                <circle class="wifi-none" cx="56" cy="77" r="5" stroke="blue" stroke-width="1" fill="black" />
                <path class="wifi-low" fill="none" stroke-width="10" stroke="lightgrey"
                      stroke-linecap="round" d="m 76 63 c -11 -11 -29 -11 -40 0"/>
                <path class="wifi-medium" fill="none" stroke-width="10" stroke="lightgrey"
                      stroke-linecap="round" d="m 93 48 c -20 -20 -53 -20 -73 0"/>
                <path class="wifi-high" fill="none" stroke-width="10" stroke="lightgrey"
                      stroke-linecap="round" d="m 109 32 c -29 -29 -76 -29 -105 0"/>
              </g>
            </svg>
          </span>
        </div>
      </div>
      <button class="group2" id="toggledrives" onclick="toggledrivesfunc();"></button>
      <p>
      <button class="group2" onclick="syncfunc();">Trigger archive/sync</button>
      <span id="synctext" style="padding-left:20px;"></span>
      <p>
      <button class="group2" onclick="startspeedtest(this);" id="speedtestbutton">Run network speed test</button>
      <span>
        <svg id="speedspinner" width="20" height="20" style="margin-left: 10px; vertical-align:middle;visibility:hidden;" viewBox="-12 -12 24 24">
          <g stroke-linecap="round" stroke-width="2">
            <path id="a" d="M0 5 0 10"/>
            <use transform="rotate(0)"   xlink:href="#a" stroke="#f0f0f0"/>
            <use transform="rotate(36)"  xlink:href="#a" stroke="#e0e0e0"/>
            <use transform="rotate(72)"  xlink:href="#a" stroke="#d0d0d0"/>
            <use transform="rotate(108)" xlink:href="#a" stroke="#c0c0c0"/>
            <use transform="rotate(144)" xlink:href="#a" stroke="#b0b0b0"/>
            <use transform="rotate(180)" xlink:href="#a" stroke="#a0a0a0"/>
            <use transform="rotate(216)" xlink:href="#a" stroke="#909090"/>
            <use transform="rotate(252)" xlink:href="#a" stroke="#808080"/>
            <use transform="rotate(288)" xlink:href="#a" stroke="#707070"/>
            <use transform="rotate(324)" xlink:href="#a" stroke="#000000"/>
          </g>
        </svg>
        <span id="speedtext" style="padding-left:10px;"></span>
      </span>
      <p>
      <button class="group2" id="rebootbutton" onclick="rebootfunc(this);">Restart Raspberry Pi</button><span id="reboottext" style="padding-left:20px;"></span>
    </div>
  </div>

  <div class="tab content5">
    <div style="width:100%;height:calc(100% - 4px);">
      <iframe class="recordings" src="TeslaCam/" onload="hideRecordingParent();"></iframe>
    </div>
  </div>

  <div class="tab content6">
    <div id="filebrowser" style="width:100%;height:calc(100% - 4px);">
    </div>
  </div>

  <div class="tab content7">
    <div style="width:100%;height:100%;background:#333;" onmousemove="showcontrols()">
      <div class="navbar">
        <div class="noclips">Loading...</div>
        <div class="subnav">RecentClips
          <div id="RecentClips" class="subnav-content"></div>
        </div>
        <div class="subnav">SavedClips
          <div id="SavedClips" class="subnav-content"></div>
        </div>
        <div class="subnav">SentryClips
          <div id="SentryClips" class="subnav-content"></div>
        </div>

        <div class="subnav layoutbtn" style="float:right;">
          <svg class="layoutsvg" width="52" height="26" viewBox="0 0 26 13">
            <path d="M 2 6 L 8 6 L 8 2 L 2 2 z M 10 6 L 16 6 L 16 2 L 10 2 z M 18 6 L 24 6 L 24 2 L 18 2 z M 2 12 L 8 12 L 8 8 L 2 8 z M 10 12 L 16 12 L 16 8 L 10 8 z M 18 12 L 24 12 L 24 8 L 18 8 z"/>
          </svg>
          <div id="layouts" class="subnav-content">
            <div class="dropdownitem layoutitem" onclick="setLayout(1)">Sides on top, rear on bottom, mirrored</div>
            <div class="dropdownitem layoutitem" onclick="setLayout(2)">Side and rear on bottom, mirrored</div>
            <div class="dropdownitem layoutitem" onclick="setLayout(3)">Side and rear on bottom, looking back</div>
            <div class="dropdownitem layoutitem" onclick="setLayout(4)">Mobile layout,<br>mirrored</div>
            <div class="dropdownitem layoutitem" onclick="setLayout(5)">Mobile layout,<br>looking back</div>
          </div>
        </div>
      </div>
      <div>
        <div class="videoholder layout3">
          <video disableRemotePlayback playsinline id="leftview" class="videogriditem leftview" style="z-index:1;"></video>
          <canvas id="leftviewfreeze" class="videogriditem leftview"  style="z-index:0;"></canvas>

          <video disableRemotePlayback playsinline id="frontview" class="videogriditem frontview" style="z-index:1;"></video>
          <canvas id="frontviewfreeze" class="videogriditem frontview" style="z-index:0;"></canvas>

          <video disableRemotePlayback playsinline id="rightview" class="videogriditem rightview" style="z-index:1;"></video>
          <canvas id="rightviewfreeze" class="videogriditem rightview" style="z-index:0;"></canvas>

          <div class="videogriditem mapview" style="margin:0px;z-index:0;">
            <iframe id="sentrymap"></iframe>
          </div>

          <video disableRemotePlayback playsinline id="backview" class="videogriditem backview" style="z-index:1;"></video>
          <canvas id="backviewfreeze" class="videogriditem backview" style="z-index:0;"></canvas>

          <div id="infoholder" class="videogriditem infoview" style="margin-left:12px;color:white;">
            <div id="sequencelocation" style="margin-top:8px;margin-bottom:8px;"></div>
            <div id="segmentname" style="margin-top:8px;margin-bottom:8px;"></div>
            <div style="margin-top:8px;">
              <span id="currenttime"></span><span id="totaltime"></span>
              <div id="debuginfo" style="margin-top:20px;"></div>
            </div>
          </div>

          <div id="videocontrols" >
            <input type="range" class="slider" id="position" name="position"
                   min="0" max="60" style="width:90%;max-width:600px;height:30px;z-index:2;"
                   onmousemove="slidermousemove(event)">
            <div class="sliderpositionbubble">00:00</div>
            <div style="width:90%;max-width:600px;height:26px;margin-top:-24px;">
              <canvas id="tickmarkscanvas" style="width:100%;height:100%;"></canvas>
            </div>
            <div class="buttoncontainer">
              <button id="skipback" class="flatbutton skipback" onclick="skipBack()">
                <svg class="mediabutton"><path d="M 19,28 A 10,10 0 1 0 9,18 M 8,18 10,18 9,20 z"></path></svg>
              </button>
              <button id="playpause" class="flatbutton play" onclick="startPlaying()">
                <svg class="mediabutton"><path></path></svg>
              </button>
              <button id="skipforward" class="flatbutton skipforward" onclick="skipForward()">
                <svg class="mediabutton"><path d="M 19,28 A 10,10 0 1 1 29,18 M 28,18 30,18 29,20 z"></path></svg>
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div id="settingsoverlay" class="modaloverlay">
    <div class="modalcontent" style="max-width:500px">
      <div style="margin-bottom:10px">
        <span>Settings</span>
        <span class="closebutton">&times;</span>
      </div>
      <div style="width:100%;padding:10px">
        <input type="checkbox" id="altui" name="altui" value="1">
        <label for="altui">Use alternative web interface</label>
      </div>
      <div style="text-align:right;padding-top:30px;">
        <button onclick="cancelsettings()">Cancel</button> <button onclick="confirmsettings()">OK</button>
      </div>
    </div>
  </div>
</div>

<script>

function localStorageGet(name) {
  try {
    return localStorage.getItem(name);
  } catch (error) {
    log(error);
  }
}

function localStorageSet(name, value) {
  try {
    localStorage.setItem(name, value);
  } catch (error) {
    log(error);
  }
}

if (document.referrer.includes("/new/")) {
  /* user switched back from the Vue UI */
  localStorageSet("usealtui", "false");
} else {
  if (localStorageGet("usealtui") == "true") {
    document.location.replace('/new/?source=legacy');
    nonExistentFunction();
  }
}

var isFirefox = navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
var isWebkit = navigator.userAgent.toLowerCase().indexOf('applewebkit') > -1;

var DEBUG = false;
var WORK_AROUND_WEBKIT_QUIRKS = true;

function log(what) {
  if (DEBUG) {
    console.log(what);
  }
}

function hideRecordingParent() {
  var i = document.querySelector(".recordings");
  if (i.contentWindow.location.pathname === "/TeslaCam/") {
    var parentlink = i.contentDocument.querySelector("#list tbody tr");
    parentlink.parentElement.removeChild(parentlink);
  }
}

function showDebugInfo() {
  if (DEBUG == false) {
    return;
  }
  var db = document.getElementById('debuginfo');
  var debuginfo = "segments: " + currentsequence.currentSegmentIdx() + "/" + currentsequence.length();
  debuginfo += ", position: ";
  for (var vid of videoelems) {
    if (vid == undefined) {
      debuginfo = debuginfo + "unused/"
    } else {
      debuginfo = debuginfo + parseInt(vid.currentTime) + "/";
    }
  }
  db.innerText = debuginfo;
}

function showcontrols() {
  var c=document.getElementById("videocontrols");
  if (c.classList.contains("shown")) {
    return;
  }
  c.classList.add("shown");
  setTimeout(function() { c.classList.remove("shown"); }, 5000);
}

showcontrols();

var currentLayout = 1;

function setLayout(layout) {
  var leftview = document.getElementById("leftview");
  var rightview = document.getElementById("rightview");
  var backview = document.getElementById("backview");
  var videogrid = document.querySelector(".videoholder");
  if (layout == 1) {
    // mirrorleft-front-mirrorright on top, map-mirrorrear-info on bottom
    leftview.classList.add("flipped");
    rightview.classList.add("flipped");
    backview.classList.add("flipped");
    videogrid.classList="videoholder layout1";
  } else if (layout == 2) {
    // map-front-info on top, mirrorleft-mirrorrear-mirrorright on bottom
    leftview.classList.add("flipped");
    rightview.classList.add("flipped");
    backview.classList.add("flipped");
    videogrid.classList="videoholder layout2";
  } else if (layout == 4) {
    // front on top, sides in middle, rear on bottom, mirrored
    leftview.classList.add("flipped");
    rightview.classList.add("flipped");
    backview.classList.add("flipped");
    videogrid.classList="videoholder layout4";
  } else if (layout == 5) {
    // front on top, sides in middle, rear on bottom
    leftview.classList.remove("flipped");
    rightview.classList.remove("flipped");
    backview.classList.remove("flipped");
    videogrid.classList="videoholder layout5";
  } else {
    layout = 3;
    // (default) map-front-info on top, right-rear-left on bottom
    leftview.classList.remove("flipped");
    rightview.classList.remove("flipped");
    backview.classList.remove("flipped");
    videogrid.classList="videoholder layout3";
  }
  currentLayout = layout;
  localStorageSet("layout", layout);

  var l = document.querySelector("#layouts.subnav-content");
  for (var i = 0; i < l.childElementCount; i++) {
    var item = l.children[i];
    if (i == (currentLayout - 1) ) {
      item.classList.add("selected");
    } else {
      item.classList.remove("selected");
    }
  }
}

function cycleLayout() {
  setLayout(currentLayout + 1);
}

setLayout(localStorageGet("layout"));

function skipBack() {
  var slider=document.getElementById('position');
  currentsequence.seekTo(parseInt(slider.value) - 10000);
}

function startPlaying() {
  currentsequence.toggleplaypause();
}

function skipForward() {
  var slider=document.getElementById('position');
  currentsequence.seekTo(parseInt(slider.value) + 30000);
}

function download(filename, text) {
  var elem = document.createElement('a');
  elem.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
  elem.setAttribute('download', filename);
  elem.style.display = 'none';
  document.body.appendChild(elem);
  elem.click();
  document.body.removeChild(elem);
}

function cachebustingurl(url) {
  return url + '?' + Math.random();
}

function isElementVisible(elem) {
  return !(window.getComputedStyle(elem).visibility === "hidden");
}

function starttailing({url, pre, button}) {
  if (!isElementVisible(pre)) {
    setTimeout(function() {
                            starttailing({url:url, pre:pre, button:button});
                          }, 1000);
    return;
  }
  log("tail " + url);
  if (pre.tailcorrection === undefined) {
    pre.tailcorrection=0;
  }
  var tailpos=pre.textContent.length - 1 + pre.tailcorrection;
  var request = new XMLHttpRequest();
  request.open('GET', cachebustingurl(url));
  request.setRequestHeader('Range', 'bytes=' + tailpos + '-' + (tailpos + 32768));
  request.onreadystatechange = function () {
    if (request.readyState === 4) {
      if (request.status === 206) {
        var left = pre.scrollLeft;
        var scrollpos=pre.scrollTop+pre.clientHeight;
        var scrollheight=pre.scrollHeight;
        var shouldgotobottom=(Math.abs(scrollpos-scrollheight) < 5)
        pre.textContent+=request.responseText.substring(1);
        if (shouldgotobottom) {
          pre.scrollTo(left,pre.scrollHeight);
        }
        setTimeout(function() {
                                starttailing({url:url, pre:pre, button:button});
                              }, 500);
      } else if (request.status === 416) {
        /* log was truncated, find the end of the currently
           displayed log in the new remote log to determine
           the offset at which we should now read. */
        log('reloading truncated log: ' + tailpos);
        var newreq = new XMLHttpRequest();
        newreq.open('GET', cachebustingurl(url));
        newreq.onreadystatechange = function () {
          if (newreq.readyState === 4) {
            if (newreq.status === 200) {
              var len=pre.textContent.length;
              var lastshown=pre.textContent.substring(len-200,len);
              var newpos=newreq.responseText.indexOf(lastshown);
              if (newpos > 0) {
                pre.tailcorrection=-(len-(newpos+200));
                starttailing({url:url, pre:pre, button:button});
                return;
              }
            }
            log('could not read file "' + url + '", status: ' + request.status);
            pre.textContent="Attempting refresh..."
            pre.tailcorrection=0;
            readfile({url:url, pre:pre.id, button:button, tail:true});
          }
        }
        newreq.send();
      } else {
        log('unexpected status: ' + request.status);
      }
    }
  }
  request.send();
}

function readfile({url, callback, callbackarg, pre, tail, button}) {
  var request = new XMLHttpRequest();
  request.open('GET', cachebustingurl(url));
  log("reading " + url);
  request.onreadystatechange = function () {
    log("read " + url + ", result: " + request.status);
    if (request.readyState === 4 && request.status === 200) {
      var type = request.getResponseHeader('Content-Type');
      if (type.indexOf("text") !== 1) {
        if (callback != null) {
          callback(request.responseText, callbackarg);
        }
        if (pre != null) {
          var preobj = document.getElementById(pre);
          preobj.textContent=request.responseText;
          if (tail === true) {
            preobj.scrollTo(0,preobj.scrollHeight);
            starttailing({url:url, pre:preobj, button:button});
          }
        }
        if (button != null) {
          var btn = document.getElementById(button);
          btn.disabled=false;
        }
      }
    }
  }
  request.send();
}

function callcgi(url) {
  var request = new XMLHttpRequest();
  request.open('GET', cachebustingurl(url));
  request.onreadystatechange = function () {
    if (request.readyState === 4 && request.status === 200) {
      var type = request.getResponseHeader('Content-Type');
      if (type.indexOf("text") !== 1) {
        return request.responseText;
      }
    }
  }
  request.send();
}

function syncfunc() {
  callcgi('cgi-bin/trigger_sync.sh');
  var msg=document.getElementById('synctext');
  msg.textContent="Sync triggered";
  setTimeout(function() { msg.textContent=""; }, 5000);
}

class Speedometer {
  amount;
  time;
  maxlength;

  constructor(maxlength) {
    this.maxlength = maxlength;
    this.amount = [0];
    this.time = [Date.now()];
  }

  addValue(value) {
    this.amount.push(value);
    this.time.push(Date.now());
    if (this.amount.length > this.maxlength) {
      this.amount.shift();
      this.time.shift();
    }
  }

  getRecentAverage() {
    if (this.time.length > 1) {
      var timeDelta = this.time[this.time.length - 1] - this.time[0];
      var amountDelta = this.amount[this.amount.length - 1] - this.amount[0];
      return 1000 * amountDelta / timeDelta;
    }
    return 0;
  }
}

var totalRandom;
var randomReader = undefined;
var speedometer;

function byteRate(speed) {
  if (speed > 500000) {
    return (speed / (1024 * 1024)).toFixed(1) + " MB/s";
  } else {
    return (speed / 1024).toFixed(1) + " KB/s";
  }
}

function bitRate(speed) {
  // for speeds under 20 Mbit, show one decimal
  return (speed * 8 / 1000000).toFixed(speed < 2500000 ? 1 : 0) + " Mbit/s";
}

function showspeed(button, indicator, spinner) {
  if (randomReader != undefined) {
    if (isElementVisible(button)) {
      speedometer.addValue(totalRandom);
      var speed = speedometer.getRecentAverage();
      var speedstring = byteRate(speed) + " (" + bitRate(speed) + ")";
      indicator.textContent = speedstring;
      setTimeout(showspeed, 1000, button, indicator, spinner);
    } else {
      stopspeedtest(button, indicator, spinner);
    }
  }
}

var lastTotalRandom = 0;
var spinAngle = 0;
function updatespeedspinner(spinner) {
  if (randomReader != undefined) {
    if (totalRandom != lastTotalRandom) {
      lastTotalRandom = totalRandom;
      spinAngle += 36;
      spinner.setAttribute('transform', 'rotate('+ spinAngle + ')');
    }
    setTimeout(updatespeedspinner, 80, spinner)
  }
}

function startspeedtest(button) {
  var indicator = document.getElementById("speedtext");
  var spinner = document.getElementById('speedspinner');
  if (randomReader == undefined) {
    log("starting speed test");
    button.textContent="Stop network speed test";
    spinner.style.visibility = "inherit";
    (async () => {
      const randomStream = await fetch('cgi-bin/randomdata.sh')
      randomReader = await randomStream.body.getReader()
      totalRandom = 0;
      speedometer = new Speedometer(5);
      setTimeout(showspeed, 1000, button, indicator, spinner);
      setTimeout(updatespeedspinner, 100, spinner);

      randomReader.read().then(function receiveRandomChunk({ done, value }) {
        if (done) {
          log("speed test end");
          return
        }
        totalRandom += value.length;
        return randomReader.read().then(receiveRandomChunk)
      })
    })()
  } else {
    stopspeedtest(button, indicator, spinner);
  }
}

function stopspeedtest(button, indicator, spinner) {
  if (randomReader != undefined) {
    log("stopping speed test");
    try {
      randomReader.cancel();
    } catch (error) {
      log(error);
    }
    randomReader = undefined;
    button.textContent="Run network speed test";
    indicator.textContent = "";
    spinner.style.visibility = "hidden";
  }
}

function setbuttonsdisabled(group, disabled) {
  var buttons=document.getElementsByClassName(group);
  for (btn of buttons) {
    btn.disabled=disabled;
  }
}

function restorerebootbutton(button) {
  button.disabled=false;
  button.textContent='Restart Raspberry Pi';
  button.onclick=function() { rebootfunc(button); };
}

function waitforreboot(button) {
  log('waitforreboot');
  var request = new XMLHttpRequest();
  request.open('GET', cachebustingurl("index.html"));
  request.setRequestHeader("Cache-Control", "no-cache, no-store, max-age=0");
  request.onreadystatechange = function () {
    log('readstatechange, state: ' + request.readyState + ', status: ' + request.status);
    if (request.readyState === 4) {
      if (request.status === 200) {
        restorerebootbutton(button);
        var msg=document.getElementById('reboottext');
        msg.textContent='';
        initialize();
        return;
      }
      log("waiting for rpi");
      window.setTimeout(function() { waitforreboot(button); }, 1000);
    }
  }
  request.send();
}

var rebootbuttonresetter;
function realrebootfunc(button) {
  clearTimeout(rebootbuttonresetter);
  setbuttonsdisabled('group1', true);
  setbuttonsdisabled('group2', true);
  callcgi('cgi-bin/reboot.sh');
  var msg=document.getElementById('reboottext');
  msg.textContent="Reboot is in progress";
  button.disabled=true;
  setTimeout(function() { waitforreboot(button); }, 5000);
}

function rebootfunc (button) {
  button.textContent="Press again to confirm reboot";
  button.onclick=function() { realrebootfunc(button); }
  rebootbuttonresetter=setTimeout(function() { restorerebootbutton(button); }, 10000);
}

async function refreshdiagnostics() {
  var btn1=document.getElementById('diagrefreshbtn');
  var btn2=document.getElementById('diagdwnbtn');
  var pre=document.getElementById('diagnosticspre');
  btn1.disabled=true;
  btn2.disabled=true;
  pre.textContent='Generating diagnostics...';

  readfile({url:'cgi-bin/diagnose.sh', callback:function(value) {
    readfile({pre:'diagnosticspre', url:'diagnostics.txt', button:'diagdwnbtn'});
    var btn=document.getElementById('diagrefreshbtn');
    btn.disabled=false;
  }});
}

function uptimeString(secs) {
  secs = Math.round(secs);
  var days = Math.trunc(secs / (24 * 3600));
  var hours = Math.trunc(secs % (24 * 3600) / 3600);
  var minutes = Math.trunc(secs % (3600) / 60);
  var seconds = Math.trunc(secs % 60);
  var out = "";
  if (days == 1) {
    out = "1 day, "
  } else if (days > 1) {
    out = days + " days, "
  }
  return out + hours.toString().padStart(2, 0) + ":" +
               minutes.toString().padStart(2,0) + ":" +
               seconds.toString().padStart(2,0);
}

function spaceString(bytes) {
  if (bytes > 1024 * 1024 * 1024) {
    return (bytes / (1024 * 1024 * 1024)).toFixed(0) + "G";
  } else if (bytes > 100 * 1024 * 1024) {
    return (bytes / (1024 * 1024 * 1024)).toFixed(1) + "G";
  } else {
    return (bytes / (1024 * 1024)).toFixed(0) + "M";
  }
}

const longDateOpts = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
const longDateFormat = new Intl.DateTimeFormat(navigator.language, longDateOpts);
const dayNameOpts = { weekday: 'long' };
const dayNameFormat = new Intl.DateTimeFormat(navigator.language, dayNameOpts);

function dateFromSeconds(seconds) {
  var d = new Date(0);
  d.setUTCSeconds(seconds);
  return longDateFormat.format(d);
}

function dayNameFromDateString(datestr) {
  /* force javascript's Date class to parse using local time
     by using yyyy/mm/dd notation instead of yyyy-mm-dd */

  var d = new Date(datestr.replaceAll("-", "/"));

  return dayNameFormat.format(d);
}

function toggledrivesfunc() {
  callcgi('cgi-bin/toggledrives.sh');
}

var statusvals;
const max_status_age = 4000;

function updateuptimeonly() {
  if (statusvals != undefined) {
    var status_age = (Date.now() - statusvals.retrieved);
    var uptime = Math.round(statusvals.uptime) + (status_age / 1000);
    var uptimediv = document.querySelector(".status_uptime");
    uptimediv.innerText = "Uptime: " + uptimeString(uptime);
  }
  if (statusvals != undefined && status_age >= max_status_age) {
    setTimeout(showstatus, 10);
  } else {
    setTimeout(updateuptimeonly, 1000);
  }
}

function showstatus() {
  var uptimediv = document.querySelector(".status_uptime");
  if (isElementVisible(uptimediv) || uptimediv.clientHeight == 0) {
    readfile({url:'cgi-bin/status.sh', callback:function(value) {
      statusvals=JSON.parse(value);
      statusvals.retrieved = Date.now();
      uptimediv.innerText = "Uptime: " + uptimeString(statusvals.uptime);

      var tempdiv = document.querySelector(".status_temp");
      if (statusvals.cpu_temp != "") {
        tempdiv.innerText = "Core temperature: " + (statusvals.cpu_temp / 1000).toFixed(1) + " C";
        tempdiv.style.display = "inherit";
      } else{
        tempdiv.style.display = "none";
      }

      var drivesdiv = document.querySelector(".status_drives");
      var togglebutton = document.getElementById("toggledrives");
      if (statusvals.drives_active != togglebutton.drives_active) {
        if (statusvals.drives_active == "yes") {
          drivesdiv.innerText = "Drives: visible to host";
          togglebutton.innerText = "Disconnect drives from host";
        } else {
          drivesdiv.innerText = "Drives: not visible to host";
          togglebutton.innerText = "Connect drives to host";
        }
        togglebutton.drives_active = statusvals.drives_active;
      }

      var drivesdiv = document.querySelector(".status_space");
      var total = statusvals.total_space;
      var used = total - statusvals.free_space;
      drivesdiv.innerText = "Disk usage: " + spaceString(used) + " (" +
                          (used * 100 / total).toFixed(0) + "%)";

      var drivesdiv = document.querySelector(".status_snapshots");
      var snaps = "Snapshots: " + statusvals.num_snapshots;
      if (statusvals.num_snapshots > 0) {
        snaps += " (" + dateFromSeconds(statusvals.snapshot_oldest);
        if (statusvals.num_snapshots > 1) {
          snaps += " - " + dateFromSeconds(statusvals.snapshot_newest);
        }
        snaps += ")";
      }
      drivesdiv.innerText = snaps;
      var etherdiv = document.querySelector(".status_ether");
      if (statusvals.ether_speed == "") {
        etherdiv.style.display="none";
      } else {
        etherdiv.style.display="";
        var etherinfospan = document.querySelector(".status_ether_info");
        var etherinfo="";
        if (statusvals.ether_speed == "Unknown!") {
          etherinfo = "Not connected."
        } else {
          etherinfo = statusvals.ether_speed + ", " + statusvals.ether_ip;
        }
        etherinfospan.innerText = etherinfo;
      }
      var wifiinfospan = document.querySelector(".status_wifi_info");
      var wifiinfo;
      var wifiicon = document.querySelector(".wifi-icon");
      var wifiiconspan = document.querySelector(".wifi-icon-span");
      if (statusvals.wifi_ssid == "") {
        wifiinfo = "Not connected.";
        wifiicon.attributes.strength.value = "-";
        wifiiconspan.setAttribute("title", "Not connected");
      } else {
        wifiinfo = statusvals.wifi_ssid + ", " +
                  (statusvals.wifi_freq/1000000000).toFixed(1) + " GHz, ";
        if (statusvals.wifi_ip == "") {
          wifiinfo += "no IP address";
        } else {
          wifiinfo += statusvals.wifi_ip;
        }
        var strength = eval(statusvals.wifi_strength);
        var str = "+".repeat(1 + 3.99 * strength);
        var wifiicon = document.querySelector(".wifi-icon");
        wifiicon.attributes.strength.value = str;
        wifiiconspan.setAttribute("title", "Signal quality: " + (strength * 100).toFixed(0) + "%");
      }
      wifiinfospan.innerText = wifiinfo;
    }});
  }
  setTimeout(updateuptimeonly, 1000);
}

var config;
function readconfig() {
  readfile({url:'cgi-bin/config.sh', callback:function(value) {
    config = JSON.parse(value);
    const filestab = document.querySelector(".tablabel6");
    var numdrives = 0;
    if (config.has_music == "yes") numdrives++;
    if (config.has_lightshow == "yes") numdrives++;
    if (config.has_boombox == "yes") numdrives++;
    if (numdrives == 1) {
      var filestabname = "Music"
      if (config.has_lightshow == "yes") filestabname = "LightShow";
      if (config.has_boombox == "yes") filestabname = "Boombox";
      filestab.innerText = filestabname;
    }
    if (numdrives > 0 && filestab.style.display == "") {
      filestab.style.display = "inline-block";

      const fb = document.querySelector("#filebrowser");
      new FileBrowser(fb, [
        ...config.has_music == "yes" ? [{ path: "fs/Music", label: "Music" }] : [],
        ...config.has_lightshow == "yes" ? [{ path: "fs/LightShow", label: "LightShow" }] : [],
        ...config.has_boombox == "yes" ? [{ path: "fs/Boombox", label: "Boombox" }] : []
      ]);
    }
  }});
}

function initialize() {
  setbuttonsdisabled('group1', true);
  setbuttonsdisabled('group2', false);
  readfile({pre:'archivelooppre', url:'archiveloop.log', tail:true, button:'aldwnbtn'});
  readfile({pre:'setuplogpre', url:'teslausb-headless-setup.log', tail:true, button:'sudwnbtn'});
  showstatus();
  refreshdiagnostics();

  var settingsbtn = document.querySelector('.settingsbutton');
  settingsbtn.onclick = showsettings;
  var closebutton = document.querySelector('.closebutton');
  closebutton.onclick = closesettings;
  window.onclick = function(event) {
    var overlay = document.getElementById("settingsoverlay");
    if (event.target == overlay) {
      overlay.style.display = "none";
    }
  }
}

function showsettings() {
  var altui = document.getElementById('altui');
  altui.checked = (localStorageGet("usealtui") == "true");
  var overlay = document.getElementById("settingsoverlay");
  overlay.style.display = "block";
}

function closesettings() {
  var overlay = document.getElementById("settingsoverlay");
  overlay.style.display = "none";
}

function cancelsettings() {
  closesettings();
}

function confirmsettings() {
  var usealtui = document.getElementById('altui').checked;
  localStorageSet("usealtui", usealtui);
  if (usealtui) {
    document.location.replace('/new/?source=legacy');
    nonExistentFunction();
  }
  closesettings();
}

function inIframe () {
  try {
    return window.self !== window.top;
  } catch (e) {
    return true;
  }
}

if (inIframe()) {
  document.location.replace('TeslaCam/');
  /* prevent further execution in this iframe and just let it reload*/
  nonExistentFunction();
}

function timeString(time_ms) {
  var seconds = parseInt(time_ms / 1000);
  var hours = parseInt(seconds / 3600);
  var minutes = parseInt((seconds % 3600) / 60);
  var seconds = seconds % 60;
  var output = "";
  if (hours != 0) {
    output = hours + ":";
  }
  output = output + minutes.toString().padStart(2, "0") + ":";
  output = output + seconds.toString().padStart(2, "0");
  return output;
}

function showCurrentTime(time) {
  var elem = document.getElementById('currenttime');
  elem.innerText = timeString(time);
}

function showCurrentSegment(segmentname) {
  var elem = document.getElementById('segmentname');
  elem.innerText = prettyname(segmentname);
}

function videoError(elem) {
  if (elem == null || elem == undefined || elem.nodeName != 'VIDEO' ||
      elem.error == null || elem.error == undefined) {
     return "unknown";
  }
  return elem.error.message;
}

/* a collection of videos that share the same timestamp */
class VideoSegment {
  group;
  sequence;
  front;
  left;
  right;
  back;
  datetime;
  numangles;
  activevideoelems = [];
  longestvideoelem;
  readytoplay;
  autoplay;
  autoseek;
  timestampMs;

  constructor(group, sequence) {
    this.group = group; // RecentClips, SavedClips or SentryClips
    this.sequence = sequence;
    this.numangles = 0;
    this.onDurationChange = this.onDurationChange.bind(this);
    this.onScanError = this.onScanError.bind(this);
    this.onTimeUpdate = this.onTimeUpdate.bind(this);
    this.onVideoEnded = this.onVideoEnded.bind(this);
    this.onVideoError = this.onVideoError.bind(this);
    this.onDblClickVideo = this.onDblClickVideo.bind(this);
    this.initdefaults();
  }

  initdefaults() {
    this.activevideoelems = [];
    this.longestvideoelem = undefined;
    this.autoplay = false;
    this.autoseek = -1;
    this.readytoplay = false;
  }

  addVideo(path) {
    if (path.includes('front')) {
      this.front=path;
    } else if (path.includes('left')) {
      this.left=path;
    } else if (path.includes('right')) {
      this.right=path;
    } else if (path.includes('back')) {
      this.back=path;
    } else {
      log("unknown video path");
      return;
    }
    if (this.timestampMs == undefined) {
      var dateStr = path.substring(0, 10);
      var timeStr = path.substring(11, 19).replaceAll("-", ":");
      var d = Date.parse(dateStr + " " + timeStr);
      this.timestampMs = d;
    }
    if (this.datetime == undefined) {
      this.datetime = path.substring(0,19);
    }
  }

  onDblClickVideo(event) {
    log(event);
    event.target.requestFullscreen();
  }

  onDurationChange(event) {
    var elem = event.target;
    this.activevideoelems = this.activevideoelems.concat(elem);
    log(this.activevideoelems.length + "/" + this.numangles + " duration: " + elem.duration);
    if (this.longestvideoelem == undefined || elem.duration > this.longestvideoelem.duration) {
      this.longestvideoelem = elem;
    }
    if (this.activevideoelems.length == this.numangles) {
      log("all videos loaded. Longest: " + this.longestvideoelem.id + ": " + this.longestvideoelem.duration);
      this.readytoplay = true;
      this.longestvideoelem.ontimeupdate = this.onTimeUpdate;
      for (var vid of this.activevideoelems) {
        vid.onended=this.onVideoEnded;
        vid.onerror=this.onVideoError;
      }
      if (this.autoseek) {
        this.seekTo(this.autoseek);
        this.autoseek = -1;
      }
      unfreezeVideoElems();
      if (this.autoplay) {
        log("autoplay was set");
        this.autoplay = false;
        this.play();
      } else {
        log("no autoplay");
      }
    }
  }

  onScanError(event) {
    var elem = event.target;
    log("scan error on '" + elem.src + "': " + videoError(elem));
    this.numangles--;
    elem.onerror = undefined;
    elem.ondurationchange = undefined;
    elem.removeAttribute('src');
    if (this.numangles == 0) {
      log("all videos failed to scan, moving to next");
      currentsequence.next();
    }
  }

  onTimeUpdate(event) {
    var elem = event.target;
    var slider=document.getElementById('position');
    // assume all segments are 60 seconds long, but correct for any shortfall
    slider.value=(60000 - (this.longestvideoelem.duration*1000)) + (currentsequence.currentSegmentIdx() * 60000) + (elem.currentTime * 1000);
    log("time: " + elem.currentTime);

    showCurrentTime(slider.value);

    showDebugInfo();

    if (currentsequence.isPlaying()) {
      for (var vid of this.activevideoelems) {
        if (vid != elem && vid.paused && !vid.ended && elem.currentTime > (elem.duration - vid.duration)) {
          log("starting vid");
          vid.play();
        }
      }
    } else {
      log("not playing");
    }
  }

  onVideoError(event) {
    var elem = event.target;
    log("video error on '" + elem.id +"' at position " + elem.currentTime + ": " + videoError(elem));
    elem.errored = true;
    this.onVideoEnded();
  }

  onVideoEnded() {
    log("onvideoended");
    for (var vid of this.activevideoelems) {
      if (!vid.ended && !vid.errored) {
        log("still playing");
        return;
      }
    }
    log("all ended");
    // all videos ended
    currentsequence.next();
  }

  select() {
    var prefix = "TeslaCam/" + this.group + "/" + this.sequence + "/";
    log("===== segment =====");
    freezeVideoElems();
    if (this.left != undefined) {
      videoelems[0].src = cachebustingurl(prefix + this.left);
    } else {
      videoelems[0].removeAttribute('src');
    }
    if (this.front != undefined) {
      videoelems[1].src = cachebustingurl(prefix + this.front);
    } else {
      videoelems[1].removeAttribute('src');
    }
    if (this.right != undefined) {
      videoelems[2].src = cachebustingurl(prefix + this.right);
    } else {
      videoelems[2].removeAttribute('src');
    }
    if (this.back != undefined) {
      videoelems[3].src = cachebustingurl(prefix + this.back);
    } else {
      videoelems[3].removeAttribute('src');
    }

    this.numangles = 0;
    for (var i=0; i < 4;i++) {
      var v = videoelems[i];
      v.ontimeupdate = undefined;
      v.onended = undefined;
      v.onerror = undefined;
      v.errored = false;
      v.ondblclick = this.onDblClickVideo;
      log("videopath: " + v.src);
      if (v.src != undefined && v.src != '') {
        log("waiting for duration for " + v.src);
        v.ondurationchange = this.onDurationChange;
        v.onerror = this.onScanError;
        this.numangles++;
      } else {
        log("source undefined for vid " + i);
      }
    }
    log("angles: " + this.numangles);

    for (var n of [this.left, this.right, this.front, this.back]) {
      if (n != undefined) {
        showCurrentSegment(n.substring(0, 19));
        break;
      }
    }
    var tt = document.getElementById('totaltime');
    tt.innerText = " / " + timeString(currentsequence.length() * 60000);

    this.initdefaults();
  }

  seekTo(position) {
    if (this.readytoplay == true) {
      log("segment seekTo " + position);
      for (var vid of this.activevideoelems) {
        // todo: account for differences in length
        vid.currentTime=position;
      }
      return;
    }
    log("deferred seekTo " + position);
    this.autoseek = position;
  }

  play() {
    if (this.readytoplay == true) {
      log("direct play");
      this.longestvideoelem.play();
      return;
    }
    log("deferred play");
    this.autoplay = true;
  }

  pause() {
    log("pause clearing autoplay");
    this.autoplay = false;
    for (var vid of this.activevideoelems) {
      vid.pause();
    }
  }
}

var ro = new ResizeObserver(entries => {
  log(entries);
  for (var entry of entries) {
    entry.target.resizeHandler();
  }
});

var m = document.getElementById('sentrymap');
m.resizeHandler = function() {
  if (currentsequence != undefined) {
    currentsequence.onMapResize();
  }
}
ro.observe(m);
var t = document.getElementById('tickmarkscanvas');
t.resizeHandler = function () {
  if (currentsequence != undefined) {
    currentsequence.onTickResize();
  }
}
ro.observe(t);

/* a sequence of VideoSegments, e.g. a single sentry event, or a day's worth of RecentClips */
class VideoSequence {
  segments;
  segmentsbytime;
  sequencegroup; // RecentClips, SavedClips or SentryClips
  sequencename;
  currentsegmentidx;
  isplaying;
  jsonfile;
  jsonparsed;
  sentryeventrel;
  subsequencestart;

  constructor(group, name) {
    this.segments = [];
    this.segmentsbytime = {};
    this.sequencegroup = group;
    this.sequencename = name;
    this.reset();
    this.jsonfile = [];
    this.jsonparsed = [];
    this.sentryeventrel = [];
    this.subsequencestart = [];
  }

  initialize() {
    /* find any gaps in the sequence so those can be indicated on the timeline */
    var subseqstart = 0;
    for (var i = 0; i < this.length(); i++) {
      var segment = this.getSegmentByIndex(i);
      var ts = segment.timestampMs;
      if ((ts - subseqstart) > 90000) {
        this.subsequencestart.push(i);
      }
      subseqstart = ts;
    }
  }

  reset() {
    this.currentsegmentidx = -1;
    this.isplaying = false;
    var b = document.getElementById('playpause');
    b.classList.remove("pause");
    if (isFirefox || isWebkit) {
      b.firstElementChild.firstChild.setAttribute('d', 'M 8,30 30,18 8,6 z');
    }
  }

  getSegmentByName(timestamp) {
    if (! this.segmentsbytime.hasOwnProperty(timestamp)) {
      var segment = new VideoSegment(this.sequencegroup, this.sequencename);
      this.segments = this.segments.concat(segment);
      this.segmentsbytime[timestamp] = segment;
    }
    return this.segmentsbytime[timestamp];
  }

  getSegmentByIndex(index) {
    return this.segments[index]
  }

  currentSegmentIdx() {
    return this.currentsegmentidx;
  }

  length() {
    return this.segments.length;
  }

  isPlaying() {
    return this.isplaying == true;
  }

  select() {
    this.reset();
    currentsequence=this;
    var slider = document.getElementById('position');
    slider.max = (this.length() * 60000) - 1;
    slider.oninput = this.onSeek.bind(this);
    slider.onmousedown = this.onSeekStart.bind(this);
    slider.onchange =  this.onSeekEnd.bind(this);
    this.seekTo(0);
    this.onMapResize();
    this.onTickResize();
    this.showSentryLocation();
  }

  currentJson() {
    var jp = undefined;
    if (this.sequencegroup == "SentryClips") {
      jp  = this.jsonparsed[0];
    } else if (this.sequencegroup == "RecentClips") {
      // if we're within 5 minutes of a Sentry event, use it
      var slider=document.getElementById('position');
      var curposrel = slider.value / slider.max;
      for (var i = 0; i < this.sentryeventrel.length; i++) {
        if (this.sentryeventrel[i] != undefined) {
          var timetoevent = this.sentryeventrel[i] * slider.max - slider.value;
          if (timetoevent > -30 * 1000 && timetoevent < 5 * 60 * 1000) {
             jp = this.jsonparsed[i];
             break;
          }
        }
      }
    }
    return jp;
  }

  onMapResize() {
    log("onMapResize");
    var m = document.getElementById('sentrymap');
    log("map resized to " + m.clientWidth + "x" + m.clientHeight);
    var jp = this.currentJson();
    if (jp != undefined && jp.est_lat != undefined && jp.est_lon != undefined) {
      var url = "https://www.bing.com/maps/embed?w=" + m.clientWidth + "&h=" + m.clientHeight +
                "&cp=" + jp.est_lat + "~" + jp.est_lon + "&lvl=18&typ=d&sty=h&src=SHELL&FORM=MBEDV8";
      log("url: " + url);
      // For some reason resize events are reported even when the size
      // didn't actually change, so don't set the url the same value
      // it already has, since that forces a refresh.
      if (m.src != url) {
        m.src = url;
      }
      m.style.visibility = "inherit";
      return;
    }

    m.style.visibility = "hidden";

    this.readJsonIfNeeded(0);
  }

  readJsonIfNeeded(idx) {
    if (this.jsonparsed[idx] != undefined) {
      // no need to parse json again
      log("already parsed json");
      return;
    }

    if (this.jsonfile[idx] === null) {
      log("json fetch in progress");
      return;
    }


    if (this.jsonfile[idx] === undefined) {
      log("no json");
      return;
    }

    var jsonurl = "TeslaCam/" + this.jsonfile[idx];
    // clear this so we only do this once
    this.jsonfile[idx] = null;
    log("starting json fetch");
    readfile({url:jsonurl, callbackarg:this, callback:function(value, thiz) {
        if (thiz != currentsequence) {
          return;
        }
        log("json read callback");
        log(value);
        thiz.jsonparsed[idx] = JSON.parse(value);
        log(thiz.jsonparsed[idx]);
        thiz.onMapResize();
        thiz.onTickResize();
        thiz.showSentryLocation();
    }});
  }

  drawTick(percent) {
    var c = document.getElementById('tickmarkscanvas');
    var t = c.getContext("2d");
    var w = c.width - 15;
    var h = c.height - 16;
    t.fillStyle = "#ffffff"
    t.beginPath();
    t.moveTo(7.5 + w * percent, 16);
    t.lineTo(7.5 + w * percent + h / 2, h + 16);
    t.lineTo(7.5 + w * percent - h / 2, h + 16);
    t.fill();
  }

  drawTickForIndex(idx) {
    log("drawTickForIndex(" + idx + ")");
    var jp = this.jsonparsed[idx];
    if (jp != undefined && jp.timestamp != undefined) {
      var eventTimeMs = Date.parse(jp.timestamp);
      var eventSegmentStartMs;
      var segmentIdx;
      for (segmentIdx = this.length() - 1; segmentIdx >= 0; segmentIdx--) {
        var segment = this.getSegmentByIndex(segmentIdx);
        var s = segment.datetime;
        eventSegmentStartMs = Date.parse(
                s.substring(0,10) + "T" + s.substring(11,13) + ":" + s.substring(14,16) + ":" + s.substring(17, 19));
        if (eventSegmentStartMs <= eventTimeMs || segmentIdx == 0) {
          break;
        }
      }
      var offsetIntoSegment = eventTimeMs - eventSegmentStartMs;
      if (offsetIntoSegment < 0) {
        /* The event time is before the first video segment. This can
           happen if there are two sentry events in short succession */
        log("negative sentry offset");
        if (offsetIntoSegment > -60000) {
          /* add one segment to the start of the sequence */
          //return drawTickForIndex(idx);
          var segment = this.getSegmentByIndex(0);
          var s = segment.datetime.substring(0,10);
          var dayclips = videos["RecentClips"][s];
          if (dayclips != undefined) {
            var prevseg;
            for (var seg of dayclips.segments) {
              if (seg.datetime == segment.datetime) {
                break;
              }
              prevseg = seg;
            }
            if (prevseg != undefined) {
              /* add found segment to start of this sequence */
              log(this);
              this.segments.unshift(prevseg);
              log(this);
              return this.select();
            }
          }
        }
        offsetIntoSegment = 0;
      }
      var eventOffsetMs = (segmentIdx * 60 * 1000) + offsetIntoSegment;
      var sequenceLengthMs = this.length() * 60 * 1000;
      var reloffset = eventOffsetMs / sequenceLengthMs;
      this.sentryeventrel[idx] = reloffset;
      this.drawTick(reloffset);
      log(eventOffsetMs / sequenceLengthMs);
      return;
    }
    this.readJsonIfNeeded(idx);
  }

  drawSubsequenceMarker(percent) {
    var c = document.getElementById('tickmarkscanvas');
    var t = c.getContext("2d");
    var w = c.width - 15;
    t.strokeStyle = "#ffffff"
    t.beginPath();
    t.moveTo(Math.round(7.5 + w * percent) + 0.5, 0);
    t.lineTo(Math.round(7.5 + w * percent) + 0.5, 18);
    t.stroke();
  }
  drawSubsequenceMarkerForIndex(idx) {
    var percent = this.subsequencestart[idx] / this.length();
    this.drawSubsequenceMarker(percent);
  }

  onTickResize() {
    var c = document.getElementById('tickmarkscanvas');
    log("tickmarks resized to " + c.clientWidth + "x" + c.clientHeight);
    c.width = c.clientWidth;
    c.height = c.clientHeight;
    for (var i = 1; i < this.subsequencestart.length; i++) {
      this.drawSubsequenceMarkerForIndex(i);
    }
    for (var i = 0; i < this.jsonfile.length; i++) {
      this.drawTickForIndex(i);
    }
  }

  showSentryLocation() {
    var d = document.getElementById("sequencelocation");
    var jp = this.currentJson();
    if (jp != undefined && jp.city != undefined) {
      d.innerText = jp.city;
    } else {
      d.innerText = "";
    }
  }

  onSeekStart(event) {
    log("seek start");
  }

  onSeek(event) {
    this.seekTo(event.target.value);
  }

  onSeekEnd(event) {
    log("seek end");
  }

  seekTo(seektime) {
    if (seektime < 0) {
      seektime = 0;
    }
    // assume each segment is exactly 1 minute long
    var slider=document.getElementById('position');
    if (seektime > parseInt(slider.max)) {
      log("seeking past max");
      seektime = slider.max;
    }
    slider.value=seektime;
    showCurrentTime(seektime);
    var index = parseInt(seektime / 60000);
    var segment = this.getSegmentByIndex(index);
    if (index != this.currentsegmentidx) {
      log("pausing current segment");
      var oldsegment = this.getSegmentByIndex(this.currentsegmentidx);
      if (oldsegment != undefined) {
        oldsegment.pause();
      }
      log("selecting new segment " + index);
      segment.select();
      if (this.isplaying) {
        log("playing new segment");
        segment.play();
      }
      this.currentsegmentidx=index;
    }
    segment.seekTo((seektime % 60000) / 1000);
    this.onMapResize();
    this.showSentryLocation();
  }

  next() {
    var nextsegment = this.currentsegmentidx + 1;
    log("next: " + this.currentsegmentidx);
    if (nextsegment >= this.length()) {
      return false;
    }
    this.seekTo(nextsegment * 60000);
    return true;
  }

  toggleplaypause() {
    if (this.isplaying) {
      this.pause();
    } else {
      this.play();
    }
  }

  play() {
    log("play: " + this.currentsegmentidx);
    this.isplaying = true;
    var segment = this.getSegmentByIndex(this.currentsegmentidx);
    segment.play();
    var b = document.getElementById('playpause');
    b.classList.add("pause");
    if (isFirefox || isWebkit) {
      b.firstElementChild.firstChild.setAttribute('d', 'M 8,30 14,30 14,6 8,6 z M 24,30 30,30 30,6 24,6 z');
    }
  }

  pause() {
    this.isplaying = false;
    var segment = this.getSegmentByIndex(this.currentsegmentidx);
    segment.pause();
    var b = document.getElementById('playpause');
    b.classList.remove("pause");
    if (isFirefox || isWebkit) {
      b.firstElementChild.firstChild.setAttribute('d', 'M 8,30 30,18 8,6 z');
    }
  }
}

var videos={};
var currentsequence;

var videoelems = [
  document.getElementById('leftview'),
  document.getElementById('frontview'),
  document.getElementById('rightview'),
  document.getElementById('backview')
];

var canvaselems = [
  document.getElementById('leftviewfreeze'),
  document.getElementById('frontviewfreeze'),
  document.getElementById('rightviewfreeze'),
  document.getElementById('backviewfreeze')
];

function freezeVideoElems() {
  for (var i=0; i < 4;i++) {
    var v = videoelems[i];
    var c = canvaselems[i];
    v.teslausbcanvaslayer = c;
    c.width = v.clientWidth;
    c.height = v.clientHeight;
    var ctx = c.getContext("2d");
    if (v.classList.contains("flipped")) {
      ctx.scale(-1, 1);
      ctx.drawImage(v, 0, 0, -c.width, c.height);
    } else {
      ctx.drawImage(v, 0, 0, c.width, c.height);
    }
    v.style.visibility="hidden";
  }
}

function unfreezeVideoElems() {
  for (var i=0; i < 4;i++) {
    var v = videoelems[i];
    if (v.src != undefined && v.src != '') {
      v.style.visibility="inherit";
    } else {
      // no src, keep video hidden and clear the canvas
      var c = v.teslausbcanvaslayer;
      var ctx = c.getContext("2d");
      ctx.clearRect(0, 0, c.width, c.height);
    }
  }

}

function prettyname(name) {
  if (name.length == 10) {
    return name;
  }

  var d = name.substr(0,10);
  var t = name.substr(11,8);

  return d + " / " + t.replaceAll("-", ":");
}

function setDropdownClick(group, item) {
  item.onclick=function(event) {
    /* unselect all the currently selected items */
    var previousselected = document.querySelectorAll('.selected:not(.layoutitem)');
    for (i of previousselected) {
      i.classList.remove('selected');
    }
    this.classList.add('selected');
    if (!this.classList.contains("dropdownitemsub") && group != "RecentClips") {
      /* the dropdown item itself was selected, so also
         select the first sub item */
      this.querySelector('.dropdownitemsub.selectable').classList.add('selected');
    }
    var d = document.getElementById(group);
    d.style.display="none";
    /* There's probably a better way, but I couldn't figure it out.
       This hides the menu dropdown when clicked, then re-enables
       once the mouse has moved so it doesn't stay hidden forever */
    document.onmousemove=function(self) {
            return function() {
                    d.style.display="";
                    document.onmousemove=undefined;};
            }(this);
    this.sequence.select();
    event.stopPropagation();
  };

}

function makeRecentsDropdownItem(group, sequence, selected) {
  var newitem = document.createElement("div");

  var itemmain = document.createElement("div");
  itemmain.className = "dropdownitemmain";
  var itemsub = document.createElement("div");
  itemsub.className = "dropdownitemsub";
  newitem.appendChild(itemmain);
  newitem.appendChild(itemsub);
  itemmain.innerHTML = prettyname(sequence.toString());

  var html = '(' + dayNameFromDateString(sequence.toString());
  var numevents = videos[group][sequence].jsonfile.length;
  if (numevents != 0) {
    html += ", " + numevents + " events";
  }
  html += ")";
  itemsub.innerHTML = html;

  newitem.group=group;
  newitem.sequence=videos[group][sequence];
  setDropdownClick(group, newitem);

  newitem.className='dropdownitem';
  if (selected) {
    newitem.classList.add('selected');
  }

  return newitem;
}

function newSentryDropdownItem(group, sequence, selected) {
  var newitem = document.createElement("div");

  var itemmain = document.createElement("div");
  itemmain.className = "dropdownitemmain";
  newitem.appendChild(itemmain);

  var date = sequence.substring(0,10);
  var itemsub = document.createElement("div");
  itemsub.className = "dropdownitemdayname";
  itemsub.innerHTML = "(" + dayNameFromDateString(date) + ")";
  newitem.appendChild(itemsub);

  itemsub = document.createElement("div");
  itemsub.className = "dropdownitemsub selectable";
  newitem.appendChild(itemsub);

  var time = sequence.substring(11);

  itemmain.innerHTML = date;
  itemsub.innerHTML = time.substring(0,5).replaceAll("-", ":");;

  newitem.group=group;
  newitem.sequence=videos[group][sequence];
  itemsub.sequence=videos[group][sequence];

  setDropdownClick(group, newitem);
  setDropdownClick(group, itemsub);
  newitem.className='dropdownitem';
  if (selected) {
    newitem.classList.add('selected');
  }

  return newitem;
}

function addToSentryDropdownItem(parent, group, sequence, selected) {
  var itemsub = document.createElement("div");
  itemsub.className = "dropdownitemsub selectable";
  parent.appendChild(itemsub);
  var time = sequence.substring(11);
  itemsub.innerHTML = time.substring(0,5).replaceAll("-", ":");
  itemsub.sequence=videos[group][sequence];
  setDropdownClick(group, itemsub);
  if (selected) {
    itemsub.classList.add('selected');
  }
}

function makeSentryDropdownItem(group, sequence, selected) {
  var d = document.getElementById(group);
  var lastdropdownitem = d.lastChild;
  var date = sequence.substring(0,10);
  if (lastdropdownitem != null && lastdropdownitem.date == date) {
    addToSentryDropdownItem(lastdropdownitem, group, sequence, selected);
    return undefined;
  }
  var newitem = newSentryDropdownItem(group, sequence, selected);
  newitem.date = date;
  return newitem;
}

function makeDropdownItem(group, sequence, selected) {
  if (group == "RecentClips") {
    return makeRecentsDropdownItem(group, sequence, selected);
  }
  return makeSentryDropdownItem(group, sequence, selected);
}

function flipdropdowns() {
    for (i of ["RecentClips", "SavedClips", "SentryClips"]) {
      var d=document.getElementById(i);
      d.append(...Array.from(d.childNodes).reverse())
    }
}
function flipdropdownsfromclick() {
  if (localStorageGet("eventorder") == "newest") {
    localStorageSet("eventorder", "oldest");
  } else {
    localStorageSet("eventorder", "newest");
  }
  flipdropdowns();
}

readconfig();

readfile({url:'cgi-bin/videolist.sh', callback:function(value) {
  var newest="0-";
  var newestsequence;
  var lines = value.split('\n');
  for (line of lines) {
    var [group, sequencename, filename] = line.split('/');
    if (sequencename == undefined) {
      continue;
    }
    if (filename.includes("~")) {
       /* skip fsck recovered files for now */
       continue;
    }
    if (sequencename.includes("json")) {
       /* this shouldn't be necessary, and can be removed once
          teslausb no longer creates an "event.json" folder */
       continue;
    }
    if (!videos.hasOwnProperty(group)) {
      videos[group]={};
    }
    var sequence;
    if (videos[group].hasOwnProperty(sequencename)) {
      sequence=videos[group][sequencename];
    } else {
      sequence=new VideoSequence(group, sequencename);
      videos[group][sequencename]=sequence;
    }
    if (filename != "event.mp4" && filename.includes(".mp4")) {
      videotime=filename.substring(0, 19);
      segment=sequence.getSegmentByName(videotime);
      segment.addVideo(filename);
      if (sequencename > newest) {
        newest = sequencename;
        newestsequence=sequence;
      }
    } else if (filename.includes("thumb")) {
      sequence.thumb=filename;
    } else if (filename.includes("json")) {
      var jsonpath = group + "/" + sequencename + "/" + filename;
      sequence.jsonfile[0] = jsonpath;
      // add the json to the RecentClips that includes this SentryClip
      var clipday = sequencename.substr(0,10);
      if (videos.hasOwnProperty("RecentClips") &&
        videos["RecentClips"].hasOwnProperty(clipday)) {
        videos["RecentClips"][clipday].jsonfile.push(jsonpath);
        log("added event json to " + clipday);
      } else {
        log("no video sequence for " + filename);
      }
    }
  }

  var nr = document.querySelector(".noclips");
  if (WORK_AROUND_WEBKIT_QUIRKS) {
    nr.style.display="none";
    nr.style.display='';
  }
  for (i of ["RecentClips", "SavedClips", "SentryClips"]) {
    var d=document.getElementById(i);
    for (c in videos[i]) {
      // Regular expression to match the date format
      var datePattern = /^\d{4}-\d{2}-\d{2}(_\d{2}-\d{2}-\d{2})?$/;

      // Check if c matches the date pattern
      if (!datePattern.test(c)) {
        log("skipping invalid date format " + i + "/" + c);
        continue;
      }
      if (videos[i][c].getSegmentByIndex(0) == undefined) {
        log("skipping empty " + i + "/" + c);
        continue;
      }
      videos[i][c].initialize();

      var newelem = makeDropdownItem(i, c, videos[i][c] == newestsequence);
      if (newelem != undefined) {
        d.appendChild(newelem);
      }
    }
    if (localStorageGet("eventorder") == "newest") {
      d.append(...Array.from(d.childNodes).reverse())
    }

    /* set an appropriate size and position for the dropdown */
    var cols = Math.trunc((document.body.clientWidth * 0.7 + 155) / 156);
    if ((d.childElementCount / cols) < 3) {
      cols = Math.ceil(d.childElementCount / 3);
    }
    if (WORK_AROUND_WEBKIT_QUIRKS) {
      d.parentElement.style.display="none";
      d.parentElement.style.display='';
    }
    if (cols < 2) {
      d.style.left = Math.max(2, d.parentElement.getBoundingClientRect().left - 8) + "px";
    }
    d.style.width = (cols * 156) + "px";
    d.parentElement.onmouseenter = function(ev) {
      setTimeout(function() {
        ev.target.onclick = flipdropdownsfromclick;}, 10);
    }
    d.parentElement.onmouseleave = function(ev) {
      ev.target.onclick = null;
    }
  }
  if (newestsequence != undefined) {
    newestsequence.select();
  }
  nr.innerHTML = "No recordings";
  initialize();
}
});

function stringtoseconds(s) {
  var secs = (3600 * s.substring(0, 2)) +
             (60 * s.substring(3, 5)) +
             (1 * s.substring(6, 8));
  return secs;
}

function secondstostring(t) {
  var hours = Math.trunc(t / 3600);
  var minutes = Math.trunc((t % 3600) / 60);
  var seconds = t % 60;
  return hours.toString().padStart(2, '0')
         + ":" + minutes.toString().padStart(2, '0')
  //     + ":" + seconds.toString().padStart(2, '0')
}

function slidermousemove(e) {
  var seq = currentsequence;
  if (seq == undefined) {
    return;
  }
  var off = e.offsetX;
  var width = e.target.clientWidth;
  /* account for inset of track/button */
  width -= 15;
  /* scale within range */
  off -= 10;
  /* offset can be outside the slider when dragging it */
  if (off >= width) {
    off = width - 1;
  }
  if (off < 0) {
    off = 0;
  }
  var len = seq.length();
  var idx = Math.trunc(len * off / width);
  var bub = document.querySelector('.sliderpositionbubble');
  bub.style.setProperty('--position', "" + (e.target.getBoundingClientRect().x + off - 25) + 'px');
  var segment = seq.getSegmentByIndex(idx);
  if (segment == undefined) {
    log("no segment for index " + idx);
    return;
  }
  var secondsinday = stringtoseconds(segment.datetime.substring(11, 19))
  // TODO maybe: interpolate to show the exact time of the cursor
  bub.innerText = secondstostring(secondsinday);
}

function toggleHamburgerMenu() {
  const brgr = document.querySelector(".hamburger");
  brgr.classList.toggle("brgropen");
  const menu = document.querySelector(".tabheaderholder");
  menu.onclick = (e) => {
    if (e.target.classList.contains("tablabel")) {
      const tabname = document.querySelector(".currenttabname");
      tabname.innerText = e.target.innerText;
    }
    brgr.classList.remove("brgropen");
    menu.onclick = null;
  }
}

function setCurrentTabName() {
  const checkedradio = document.querySelector(".tabradiobtn:checked");
  const checkedlabel = document.querySelector(`label[for=${checkedradio.id}]`).textContent;
  const tabname = document.querySelector(".currenttabname");
  tabname.innerText = checkedlabel;
}

setCurrentTabName();

const mediaQuery = window.matchMedia('screen and (max-width: 824px)');
mediaQuery.addListener(setCurrentTabName);


</script>
</body>
</html>
